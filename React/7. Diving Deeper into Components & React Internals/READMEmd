# Diving Deeper into Components & React Internals

##  Splitting an App Into Components

directories

```shell
src
└ assets
└ components #stateless, dumb, presentational component 
	└ Cockpit
		Cockpit.js
		Cockpit.css
	└ Persons
		└Person
			Person.js
		Persons.js
└ containers #stateful, smart component
	App.js
	App.css
```



## Class-based vs Functional Components

|                         class-based                          |         functional          |
| :----------------------------------------------------------: | :-------------------------: |
|                  class XY extends Component                  |  const XY = props=>{....}   |
| Access to State(<br />access: this.state<br />change: setState) | Access to State(useState()) |
|                      Lifecycle Hooks O                       |      Lifecycle Hooks X      |
|              Access State and Props via 'this'               |  Access Props via 'props'   |
| Use if you need to manage State or access to Lifecycle Hooks and you don't want to use React Hooks |   Use in all other Cases    |

```javascript
// index.js
ReactDOM.render(<App title='Title'/>, document.getElementById('root'));
```

```javascript
//App.js
<Person title = {this.props.title}/>
```

# [Lifecycle](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

## Component Lifecycle - Creation

|                                        | Do                                | Don't                                  |
| -------------------------------------- | --------------------------------- | -------------------------------------- |
| constructor(props)                     | Set up State                      | Cause Side-Effects                     |
| getDerivedStateFromProps(props, state) | Sync state                        | Cause Side-Effects                     |
| render()                               | Prepare & Structure your JSX Code |                                        |
| Render Child Components                |                                   |                                        |
| componentDidMount()                    | Cause Side-Effects                | Update State(it'll triggers re-render) |

```js
//App.js
class App extends Component{
    constructor(props){
        super(props);
        console.log('[App.js] constructor')
        this.state = {
            
        } // initialize state
	}
}

static getDerivedStateFromProps(props,state){
    console.log('[App.js] getDerivedStateFromProps', props);
    return state
}

componentDidMount(){
	console.log('[App.js] componentDidMount')
}

render(){
	console.log('[App.js] render')
    
    persons = (
    	<Persons/>
    )
}
```

```javascript
// Persons.js
const persons = props =>{
	console.log('[Persons.js] rendering...')
	return props.persons.map((person, index) => {
		
	})
}
	
```

```javascript
// Person.js
const person = props =>{
	console.log('[Person.js] rendering...')
	return 대충 jsx
}
	
```

```bash
# 실행 결과
[App.js] constructor
[App.js] getDerivedStateFromProps
[App.js] render
[App.js] componentDidMount
# Toggle Button 클릭
[App.js] getDerivedStateFromProps
[App.js] render
[Persons.js] rendering...
[Person.js] rendering...
[Person.js] rendering...
[Person.js] rendering...
```



## Component Lifecycle - Update

|                                                              | Do                                | Don't                                       |
| ------------------------------------------------------------ | --------------------------------- | ------------------------------------------- |
| getDerivedStateFromPops(props, state)                        | Sync state to Props               | Cause Side-Effects(don't send http request) |
| shouldComponentUpdate(nextProps, nextState); May cancel updating process | Decide whether to Continue or Not | Cause Side-Effects                          |
| render()                                                     | Prepare & Structure your JSX Code |                                             |
| Update Child Components Props                                |                                   |                                             |
| getSnapshotBeforeUpdate(prevProps, prevState)                | Last-minute DOM ops               | Cause Side-Effects                          |
| componentDidUpdate()                                         | Cause Side-Effects                | Update State(triggers re-render)            |

```javascript
// Persons.js
// LifeCycle Hook을 확인하기 위해 Class-based로 수정

class Persons extends Component {
    static getDerivedStateFromPops(props, state){
        console.log('[Persons.js] getDerivedStateFromPops');
        return state;
	}
    
    shouldComponentUpdate(nextProps, nextState){
        console.log('[Persons.js] shouldComponentUpdate');
        
        // true일 경우 업데이트를 계속 진행
        // false일 경우 업데이트를 멈춤
        return true ;
	}
    
    getSnapshotBeforeUpdate(prevProps, prevState){
        console.log('[Persons.js] getSnapshotBeforeUpdate');
        return { message:'Snapshot!'}; // Snapshot value or null
        // snapshot은 data package
        // update 직전의 state의 저장이 가능
    }
    
    componentDidUpdate(prevProps, prevState, snapshot){
        console.log('[Persons.js] componentDidUpdate');
        console.log(snapshot); // 이게 가능해
    }
    
    componentWillUnmount() {
    	console.log('[Persons.js] componentWillUnmount');
  	}
    
    render(){
        console.log('[Persons.js] rendering...');
	}
}
```

```bash
# 실행 결과
[App.js] constructor
[App.js] getDerivedStateFromProps
[App.js] render
[App.js] componentDidMount
# input typing
# text 창에 글자를 입력해야 person의 변화가 생기고 Lifecycle Hook 이 trigger 된다.
[App.js] getDerivedStateFromProps
[App.js] render
[Persons.js] shouldComponentUpdate
[Persons.js] rendering...
[Person.js] rendering...
[Person.js] rendering...
[Person.js] rendering...
[Persons.js] getSnapshotBeforeUpdate
[Persons.js] componentDidUpdate
```

person 이 업데이트 될 때, App의 state도 변경이 되니까

App도 업데이트 트리거 할 수 있는데 하고 싶으면 해 봐

## useEffect

### basic settings

- Component 이름은 대문자로 시작해야 한다. const cockpit => const Cockpit

```javascript
// Cockpit.js
const Cockpit = props => {
  useEffect(() => {
    console.log('[Cockpit.js] useEffect');
  });
   ...
```

- `state 변화 -> render 실행 -> 콕핏 실행`의 과정을 거치기 때문에, cockpit에 직접적인 변화가 없더라도 매번 실행 된다.
- componentDidMount 와 compenentDidUpdate가 섞여있다고도 볼 수 있다.
- 그렇다면 이를 어떻게 컨트롤 할 수 있을 것인가?

```javascript
// Cockpit.js
const Cockpit = props => {
  useEffect(() => {
    console.log('[Cockpit.js] useEffect');
  }, [props.persons]);
   ...
```

- 위와 같이 useEffect의 두번째 인자로 배열을 주면, 배열 안에 있는 요소에 변경이 생길 때만 실행이 된다.
- 만약 빈 배열을 넣을 경우, 맨 처음 한번만 실행되고 재실행이 되지 않는다.(componentDidMount 와 같은 동작)

### cleanup

```javascript
useEffect(() => {
    console.log('[Cockpit.js] useEffect');
    return () => {
        console.log('[Cockpit.js] cleanup work in useEffect');
    };
}, []);
```

- return 구문에 함수를 작성하면, unmount 될 때 함수가 실행된다.
- 위와 같이 useEffect를 작성하면, 두번째 인자가 빈 배열이기 때문에, component가 mount되어 render 될 때 `console.log('[Cockpit.js] useEffect')`가 한 번 실행되고, unmount 될 때 `console.log('[Cockpit.js] cleanup work in useEffect')` 가 실행 된다.



```javascript
useEffect(() => {
    console.log('[Cockpit.js] 2nd useEffect');
    return () => {
        console.log('[Cockpit.js] cleanup work in 2nd useEffect');
    };
});
```

- 두번 째 인자가 없을 때에는, re-rendering이 될 때 마다 실행 된다.
- 어떠한 component가 re-render 되던 간에 re-render가 발생할 때마다 실행되게 해야할 경우 사용되는 방법 

cleanup 예제)

```javascript
useEffect(() => {
    console.log('[Cockpit.js] useEffect');

    const timer = setTimeout(() => {
      alert('Saved data to cloud!');
    }, 1000);
    return () => {
      clearTimeout(timer);
      console.log('[Cockpit.js] cleanup work in useEffect');
    };
  }, []);
```

clearTimeout을 설정하지 않은 상태에서 실행하면, 창을 로드하고 바로 `Remove Cockpit` 버튼을 누르더라도 1초 후 alert 창이 뜬다. 하지만 위 코드 처럼 설정을 하면 `Remove Cockpit` 버튼을 누를 때, unmount가 되어 return 함수가 실행되기 때문에, timer가 동작을 멈추게 되고 결과적으로 1초가 경과해도 경고창이 나오지 않는다.