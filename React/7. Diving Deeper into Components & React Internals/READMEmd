# Diving Deeper into Components & React Internals

##  Splitting an App Into Components

directories

```shell
src
└ assets
└ components #stateless, dumb, presentational component 
	└ Cockpit
		Cockpit.js
		Cockpit.css
	└ Persons
		└Person
			Person.js
		Persons.js
└ containers #stateful, smart component
	App.js
	App.css
```



## Class-based vs Functional Components

|                         class-based                          |         functional          |
| :----------------------------------------------------------: | :-------------------------: |
|                  class XY extends Component                  |  const XY = props=>{....}   |
| Access to State(<br />access: this.state<br />change: setState) | Access to State(useState()) |
|                      Lifecycle Hooks O                       |      Lifecycle Hooks X      |
|              Access State and Props via 'this'               |  Access Props via 'props'   |
| Use if you need to manage State or access to Lifecycle Hooks and you don't want to use React Hooks |   Use in all other Cases    |

```javascript
// index.js
ReactDOM.render(<App title='Title'/>, document.getElementById('root'));
```

```javascript
//App.js
<Person title = {this.props.title}/>
```

# [Lifecycle](http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

## Component Lifecycle - Creation

|                                        | Do                                | Don't                                  |
| -------------------------------------- | --------------------------------- | -------------------------------------- |
| constructor(props)                     | Set up State                      | Cause Side-Effects                     |
| getDerivedStateFromProps(props, state) | Sync state                        | Cause Side-Effects                     |
| render()                               | Prepare & Structure your JSX Code |                                        |
| Render Child Components                |                                   |                                        |
| componentDidMount()                    | Cause Side-Effects                | Update State(it'll triggers re-render) |

```js
//App.js
class App extends Component{
    constructor(props){
        super(props);
        console.log('[App.js] constructor')
        this.state = {
            
        } // initialize state
	}
}

static getDerivedStateFromProps(props,state){
    console.log('[App.js] getDerivedStateFromProps', props);
    return state
}

componentDidMount(){
	console.log('[App.js] componentDidMount')
}

render(){
	console.log('[App.js] render')
    
    persons = (
    	<Persons/>
    )
}
```

```javascript
// Persons.js
const persons = props =>{
	console.log('[Persons.js] rendering...')
	return props.persons.map((person, index) => {
		
	})
}
	
```

```javascript
// Person.js
const person = props =>{
	console.log('[Person.js] rendering...')
	return 대충 jsx
}
	
```

![create](https://user-images.githubusercontent.com/40619551/64921443-35747380-d7fe-11e9-8444-2f2d2c32fa6b.gif)





## Component Lifecycle - Update

|                                                              | Do                                | Don't                                       |
| ------------------------------------------------------------ | --------------------------------- | ------------------------------------------- |
| getDerivedStateFromPops(props, state)                        | Sync state to Props               | Cause Side-Effects(don't send http request) |
| shouldComponentUpdate(nextProps, nextState); May cancel updating process | Decide whether to Continue or Not | Cause Side-Effects                          |
| render()                                                     | Prepare & Structure your JSX Code |                                             |
| Update Child Components Props                                |                                   |                                             |
| getSnapshotBeforeUpdate(prevProps, prevState)                | Last-minute DOM ops               | Cause Side-Effects                          |
| componentDidUpdate()                                         | Cause Side-Effects                | Update State(triggers re-render)            |

### props change


```javascript
// Persons.js
// LifeCycle Hook을 확인하기 위해 Class-based로 수정

class Persons extends Component {
    static getDerivedStateFromPops(props, state){
        console.log('[Persons.js] getDerivedStateFromPops');
        return state;
	}
    
    shouldComponentUpdate(nextProps, nextState){
        console.log('[Persons.js] shouldComponentUpdate');
        
        // true일 경우 업데이트를 계속 진행
        // false일 경우 업데이트를 멈춤
        return true ;
	}
    
    getSnapshotBeforeUpdate(prevProps, prevState){
        console.log('[Persons.js] getSnapshotBeforeUpdate');
        return { message:'Snapshot!'}; // Snapshot value or null
        // snapshot은 data package
        // update 직전의 state의 저장이 가능
    }
    
    componentDidUpdate(prevProps, prevState, snapshot){
        console.log('[Persons.js] componentDidUpdate');
        console.log(snapshot); // 이게 가능해
    }
    
    componentWillUnmount() {
    	console.log('[Persons.js] componentWillUnmount');
  	}
    
    render(){
        console.log('[Persons.js] rendering...');
	}
}
```

![update props](https://user-images.githubusercontent.com/40619551/64921710-7c179d00-d801-11e9-8b8a-1353bd0ce4a8.gif)



### state change

```javascript
//App.js
class App extends Component{
    constructor(props){
        super(props);
        console.log('[App.js] constructor')
        this.state = {
            
        } // initialize state
	}
}

static getDerivedStateFromProps(props,state){
    console.log('[App.js] getDerivedStateFromProps', props);
    return state
}

componentDidMount(){
	console.log('[App.js] componentDidMount')
}

shouldComponentUpdate() {
    console.log('[App.js] shouldComponentUpdate');
    return true;
}

componentDidUpdate(){
    console.log('[App.js] componentDidUpdate')
}

render(){
	console.log('[App.js] render')
    
    persons = (
    	<Persons/>
    )
}
```

![update state](https://user-images.githubusercontent.com/40619551/64921823-c2b9c700-d802-11e9-9c35-c82f318e6098.gif)

## useEffect

### basic settings

- Component 이름은 대문자로 시작해야 한다. const cockpit => const Cockpit

```javascript
// Cockpit.js
const Cockpit = props => {
  useEffect(() => {
    console.log('[Cockpit.js] useEffect');
  });
   ...
```

![uE1](https://user-images.githubusercontent.com/40619551/64921964-de719d00-d803-11e9-93d5-f0dbc51c4cd4.gif)


- `state 변화 -> render 실행 -> 콕핏 실행`의 과정을 거치기 때문에, cockpit에 직접적인 변화가 없더라도 매번 실행 된다.
- componentDidMount 와 compenentDidUpdate가 섞여있다고도 볼 수 있다.
- 그렇다면 이를 어떻게 컨트롤 할 수 있을 것인가?

```javascript
// Cockpit.js
useEffect(() => {
    console.log('[Cockpit.js] useEffect');
    setTimeout(() => {
      alert('Saved data to cloud');
    }, 1000);
  }, [props.persons]);
   ...
```

- 위와 같이 useEffect의 두번째 인자로 배열을 주면, 배열 안에 있는 요소에 변경이 생길 때만 실행이 된다.![uE2](https://user-images.githubusercontent.com/40619551/64921997-72436900-d804-11e9-9f56-c35c4b4f1dd3.gif)
- 만약 빈 배열을 넣을 경우, useEffect 메소드가 맨 처음 한번만 실행되고 재실행이 되지 않는다.(componentDidMount 와 같은 동작)
- [동작 예시 생략]

### cleanup

```javascript
//Cockpit.js
useEffect(() => {
    console.log('[Cockpit.js] useEffect');
    return () => {
        console.log('[Cockpit.js] cleanup work in useEffect');
    };
}, []);

//App.js
this.state = {
      ...
      showCockpit: true
    };
...
 return (
      <div className={styles.App}>
        <button onClick={() => this.setState({ showCockpit: false })}>
          Remove Cockpit
        </button>
        {this.state.showCockpit ? (
          <Cockpit
            persons={this.state.persons}
            showPersons={this.state.showPersons}
            clicked={this.togglePersonsHandler}
          />
        ) : null}
        {persons}
      </div>
    );
```

- return 구문에 함수를 작성하면, unmount 될 때 함수가 실행된다.

- 위와 같이 useEffect를 작성하면, 두번째 인자가 빈 배열이기 때문에, component가 mount되어 render 될 때 `console.log('[Cockpit.js] useEffect')`가 한 번 실행되고, unmount 될 때 `console.log('[Cockpit.js] cleanup work in useEffect')` 가 실행 된다.

  ![cleanup](https://user-images.githubusercontent.com/40619551/64922126-7ff9ee00-d806-11e9-91af-cbec79dd1c84.gif)

  

- 두 번째 인자가 없는 경우

```javascript
useEffect(() => {
    console.log('[Cockpit.js] 2nd useEffect');
    return () => {
        console.log('[Cockpit.js] cleanup work in 2nd useEffect');
    };
});
```

- 두 번째 인자가 없을 때에는, re-rendering이 될 때 마다 실행 된다.

- 어떠한 component가 re-render 되던 간에 re-render가 발생할 때마다 실행되게 해야할 경우 사용되는 방법 

  [동작 예시 생략]

cleanup 예제)

```javascript
useEffect(() => {
    console.log('[Cockpit.js] useEffect');

    const timer = setTimeout(() => {
      alert('Saved data to cloud!');
    }, 1000);
    return () => {
      clearTimeout(timer);
      console.log('[Cockpit.js] cleanup work in useEffect');
    };
  }, []);
```

clearTimeout을 설정하지 않은 상태에서 실행하면, 창을 로드하고 바로 `Remove Cockpit` 버튼을 누르더라도 1초 후 alert 창이 뜬다. 하지만 위 코드 처럼 설정을 하면 `Remove Cockpit` 버튼을 누를 때, unmount가 되어 return 함수가 실행되기 때문에, timer가 동작을 멈추게 되고 결과적으로 1초가 경과해도 경고창이 나오지 않는다.
[동작 예시 생략]

### shouldComponentUpdate 를 이용한 최적화

문제 상황: state가 업데이트 될 때, person에 변화가 없어도 App이 re-rendering 되는 과정에서, Persons도 re-rendering 되는 낭비가 발생. 한 예로, `Remove Cockpit` 버튼을 누르면, person에는 변화가 없음에도, re-rendering이 일어남.

![what](https://user-images.githubusercontent.com/40619551/64922862-e6830a00-d80e-11e9-8be5-4a346c52f6e0.gif)

shouldComponentUpdate에서 현재 props와 nextProps를 비교하여 분기할 수 있다.

```javascript
// persons.js
shouldComponentUpdate(nextProps, nextState) {
    console.log('[Persons.js] shouldComponentUpdate');
    if (nextProps.persons !== this.props.persons) return true;
    else return false;
}
```

- 여기서 중요한 점은 nextProps.persons와 this.props.persons는 배열이기 때문에 **얕은 비교** 즉 **포인터의 비교**가 일어난 다는 것이다. App.js 를 살펴보면, persons에 변화가 있을 때에 `const persons = [...this.state.persons];` 와 같이 새로운 배열을 할당해주기 때문에, **포인터의 변화**가 발생한다. 만약 여기서 `const persons = this.state.persons;`와 같이 같은 persons의 주소에 변화를 주지 않았다면, 값이 바뀌어도 주소값이 같기 때문에 shouldComponentUpdate가 재대로 동작하지 않았을 것이다. 

[동작 예시 생략]

- Rendering Tip in Chrome
![tip](https://user-images.githubusercontent.com/40619551/64923161-4dee8900-d812-11e9-8ad4-860109bf7279.gif)
- DOM 에서의 변경 감지?

